---
description: Histoire story patterns and conventions for Vue components in StoryCMS Kit
globs: src/frontend/**/*.story.vue
alwaysApply: false
---

# Histoire Stories Development Rules

## Story File Structure

### File Naming Convention

- Use kebab-case for story file names
- Always end with `.story.vue` extension
- Place stories in the same directory as the component they document
- Example: `string-field.story.vue` for `string-field.vue`
- Ensure the group matches the folder they are in, example folder streams should be group="streams"

### Basic Story Template

```vue
<template>
  <Story title="Component Name" group="category">
    <Variant title="Default">
      <ComponentName :prop="value" />
    </Variant>
  </Story>
</template>

<script setup lang="ts">
import ComponentName from './component-name.vue';
</script>

<docs lang="md">
# Component Name
</docs>
```

## Story Organization

### Story Groups

Use consistent group names for organizing stories:

- `widgets` - Field components (string, boolean, markdown, etc.)
- `shared` - Reusable UI components (buttons, layouts, etc.)
- `pages` - Page-level components
- `stories` - Story-related components
- `dashboard` - Dashboard components
- `streams` - Streams and drop management
- `team` - User management components
- `auth` - Authentication components
- `audiences` - Audience management components

### Variant Naming

Use descriptive variant titles that explain the state being demonstrated:

- `Default` - Basic component state
- `With data` - Component with populated data
- `Empty` - Component with no data
- `Error` - Component showing error states
- `Readonly` - Component in read-only mode
- `RTL` - Right-to-left language support
- `Loading` - Component in loading state
- `Disabled` - Component in disabled state

## Field Component Stories

### Standard Field Story Pattern

```vue
<template>
  <Story title="Field Name" group="widgets">
    <Variant title="With model" :setup-app="loadData">
      <FieldComponent :field="spec" />
      <ModelControl :model="model" :is-inspect-only="true" />
    </Variant>

    <Variant title="Error" :setup-app="loadData">
      <FieldComponent :field="spec" />
      <template #controls>
        <ErrorControl :errors="errors" />
      </template>
    </Variant>

    <Variant title="RTL">
      <FieldComponent :dir="isRtl ? 'rtl' : 'ltr'" :field="spec" />
      <LanguageControl />
    </Variant>

    <Variant title="Readonly" :setup-app="loadData">
      <FieldComponent :field="spec" :is-read-only="true" />
    </Variant>
  </Story>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import FieldComponent from './field-component.vue';
import LanguageControl from '../test/language-control.vue';
import ErrorControl from '../test/error-control.vue';
import ModelControl from '../test/model-control.vue';
import { useModelStore, useSharedStore } from '../store';
import type { StoryHandler } from '../shared/helpers';

const isRtl = computed(() => {
  return useSharedStore().isRtl;
});

const loadData: StoryHandler = ({ variant }): void => {
  const store = useModelStore();
  const shared = useSharedStore();

  store.model = model;
  if (variant?.title === 'Error') {
    shared.errors = errors;
  }
  if (variant?.title === 'Readonly') {
    store.setSource({
      // readonly data
    });
  }
};

const spec = {
  name: 'fieldName',
  label: 'Field Label',
  widget: 'widgetType',
};
</script>
```

------ checked up to here

### Required Variants for Field Components

1. **With model** - Component with populated data and ModelControl
2. **Error** - Component showing validation errors with ErrorControl
3. **RTL** - Right-to-left language support with LanguageControl
4. **Readonly** - Component in read-only mode

### Optional Variants for Field Components

- **Empty** - Component with no initial data
- **Loading** - Component in loading state
- **Disabled** - Component in disabled state
- **Custom states** - Component-specific variations

## Page Component Stories

### Page Story Pattern

```vue
<template>
  <Story title="Page Name" group="pages">
    <Variant title="Default" :setup-app="miniSidebar">
      <PageComponent
        :meta="sharedProps.meta"
        :user="sharedProps.user"
        :languages="sharedProps.languages"
        :language="sharedProps.language"
        :errors="sharedProps.errors"
        :stories="['John', 'Acts']"
        :data="pageData"
      />
    </Variant>
  </Story>
</template>

<script setup lang="ts">
import PageComponent from './page-component.vue';
import { sharedProps, miniSidebar } from '../test/mocks';
</script>
```

### Required Props for Page Components

- `meta` - CMS metadata from `sharedProps.meta`
- `user` - User data from `sharedProps.user`
- `languages` - Available languages from `sharedProps.languages`
- `language` - Current language from `sharedProps.language`
- `errors` - Error state from `sharedProps.errors`
- `stories` - Available stories array

## Test Controls

### ModelControl

Use `ModelControl` to display and inspect component data:

```vue
<ModelControl :model="model" :is-inspect-only="true" />
```

### ErrorControl

Use `ErrorControl` to simulate validation errors:

```vue
<template #controls>
  <ErrorControl :errors="errors" />
</template>
```

### LanguageControl

Use `LanguageControl` for RTL/LTR language testing:

```vue
<LanguageControl />
```

## Mock Data

### Importing Mocks

Import mock data from `../test/mocks`:

```typescript
import { sharedProps, miniSidebar, objectModel, objectErrors } from '../test/mocks';
```

### Common Mock Objects

- `sharedProps` - Standard page props (meta, user, languages, etc.)
- `objectModel` - Sample form data
- `objectErrors` - Sample validation errors
- `miniSidebar` - Story handler to close sidebar

### Creating Custom Mocks

Define component-specific mock data in the story file:

```typescript
const customModel = {
  fieldName: 'value',
  nestedField: {
    subField: 'subValue',
  },
};

const customErrors = {
  'bundle.fieldName': ['required validation failed'],
};
```

## Story Handlers

### Setup App Pattern

Use `setup-app` prop with StoryHandler for complex setup:

```typescript
const loadData: StoryHandler = ({ variant }): void => {
  const store = useModelStore();
  const shared = useSharedStore();

  store.model = model;

  if (variant?.title === 'Error') {
    shared.errors = errors;
  }

  if (variant?.title === 'Readonly') {
    store.setSource(readonlyData);
  }
};
```

### Common Setup Patterns

- **Load data** - Set model store with component data
- **Set errors** - Configure shared store with validation errors
- **Set readonly** - Configure component for read-only mode
- **Set language** - Configure RTL/LTR language support

## Layout and Styling

### Grid Layout

Use grid layout for multiple component variations:

```vue
<Story title="Component" group="category" :layout="{ type: 'grid', width: 500 }"></Story>
```

### Background Colors

Test components on different backgrounds:

```vue
<Variant title="Light mode">
  <div class="bg-white">
    <ComponentName />
  </div>
</Variant>
```

###Interactive elements like buttons
Ensure a visual component to test when an interactive element is used, not a console.log.

### Responsive Testing

Test components at different screen sizes using Histoire's responsive controls.

## Documentation

### Story Documentation

Add documentation using the `<docs>` block:

````vue
<docs lang="md"></docs>
````

## Props

- `prop` - Description of the prop
  </docs>

```

### Component Documentation
Document:
- Component purpose and usage
- Required and optional props
- Events emitted
- Examples of common use cases
- Accessibility considerations

## Testing Considerations

### Interactive Testing
- Test all user interactions
- Verify form submissions
- Test keyboard navigation
- Test screen reader compatibility

### State Testing
- Test all possible component states
- Verify error handling
- Test loading states
- Test disabled states

### Edge Cases
- Test with empty data
- Test with very long content
- Test with special characters
- Test with different languages

## Performance

### Story Performance
- Keep story files lightweight
- Use efficient mock data
- Avoid complex computations in stories
- Use lazy loading for large components

### Component Testing
- Test component rendering performance
- Verify memory usage
- Test with large datasets
- Monitor bundle size impact

## Accessibility

### Accessibility Testing
- Test keyboard navigation
- Verify ARIA attributes
- Test screen reader compatibility
- Test color contrast
- Test focus management

### Inclusive Design
- Test with different languages
- Test RTL/LTR layouts
- Test with assistive technologies
- Consider cognitive accessibility

## Best Practices

### Story Organization
- Group related variants together
- Use consistent naming conventions
- Keep stories focused and specific
- Document complex interactions

### Code Quality
- Use TypeScript for type safety
- Follow Vue 3 Composition API patterns
- Use proper prop validation
- Implement proper error handling

### Maintenance
- Keep stories up to date with component changes
- Remove obsolete variants
- Update documentation regularly
- Test stories after component updates
```
