---
description: Vue 3 component development patterns and conventions for StoryCMS Kit
globs: src/frontend/**/*.vue
alwaysApply: false
---

# Vue Components Development Rules

## Component Structure

### Template Structure

- Use kebab-case for component names in template
- Place template at the top of the file
- Use semantic HTML elements
- Prefer `v-if` over `v-show` for conditional rendering
- Use `v-for` with `:key` for list rendering

### Script Setup Pattern

- Use `<script setup lang="ts">` for all components
- Import dependencies at the top
- Use `defineProps` and `defineEmits` for component interface
- Use `computed` for reactive derived state
- Use `ref` for reactive primitive values

### Component Naming

- Use PascalCase for component file names
- Use kebab-case for component usage in templates
- Export components from `src/frontend/index.ts`

## Props and Events

### Props Definition

```typescript
// Use commonProps for field components
const props = defineProps({
  ...commonProps,
});

// For custom props, use TypeScript interfaces
interface CustomProps {
  title: string;
  isActive?: boolean;
}

const props = defineProps<CustomProps>();
```

### Events Definition

```typescript
const emit = defineEmits<{
  (e: 'tap'): void;
  (e: 'update', value: string): void;
}>();
```

## State Management

### Store Usage

- Use Pinia stores for global state
- Import stores from `../store`
- Use `useModelStore()` for form data
- Use `useSharedStore()` for UI state

### Local State

```typescript
const inputRef = ref<HTMLInputElement | null>(null);
const isVisible = ref(false);
const selectedItems = ref<string[]>([]);
```

## Field Components

### Field Component Pattern

- Use `commonProps` for field components
- Implement `fieldPath` computed property
- Handle `isReadOnly` and `isNested` states
- Use `input-field` and `input-label` classes
- Implement error handling with `hasError` computed

### Field Component Structure

```vue
<template>
  <div :class="fieldWrapperClasses">
    <label :for="field.label" class="input-label">
      {{ field.label }}
    </label>
    <div class="mt-[2px] pt-1 sm:col-span-2 sm:mt-0">
      <!-- Input element -->
      <p v-if="hasError" class="text-sm text-error">{{ errors[0] }}</p>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, ref, nextTick } from 'vue';
import type { FieldSpec } from '../../types';
import { useModelStore, useSharedStore } from '../store';
import { commonProps } from '../shared/helpers';

const props = defineProps({
  ...commonProps,
});

const model = useModelStore();
const shared = useSharedStore();

const field = computed(() => props.field as FieldSpec);
const fieldPath = computed(() => {
  if (props.rootPath === undefined) return field.value.name;
  return `${props.rootPath}.${field.value.name}`;
});

const errors = computed(() => shared.errorMessages(fieldPath.value));
const hasError = computed(() => errors.value.length > 0 && !props.isReadOnly);
</script>
```

## Shared Components

### Button Components

- Use `btn` and `btn-blue` classes for buttons
- Implement proper accessibility attributes
- Use `Icon` component for button icons
- Handle click events with `@click.prevent`

### Layout Components

- Use `AppLayout` for main application layout
- Use `PublicLayout` for public pages
- Implement responsive design with Tailwind classes
- Use CSS Grid and Flexbox for layouts

## Performance Patterns

### Reactive Updates

- Use `model.$subscribe()` for store updates
- Use `nextTick()` for DOM updates after state changes
- Implement proper cleanup in `onUnmounted`

### Computed Properties

- Use computed properties for derived state
- Avoid complex computations in templates
- Cache expensive operations

## Error Handling

### Field Validation

- Use `shared.errorMessages()` for field errors
- Display errors below input fields
- Use `text-error` class for error styling
- Check `hasError` computed before showing errors

### Component Errors

- Use try-catch blocks for async operations
- Implement proper error boundaries
- Log errors for debugging

## Accessibility

### ARIA Attributes

- Use proper `aria-` attributes
- Implement keyboard navigation
- Use semantic HTML elements
- Provide proper focus management

### Screen Reader Support

- Use descriptive labels
- Implement proper heading hierarchy
- Use `alt` attributes for images
- Test with screen readers

## Testing Considerations

### Component Testing

- Write unit tests for component logic
- Test prop validation
- Test event emissions
- Test error states

### Integration Testing

- Test component interactions
- Test form submissions
- Test navigation flows
- Test responsive behavior
