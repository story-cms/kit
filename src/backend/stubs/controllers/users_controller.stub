{{{
  exports({ to: app.makePath('app/controllers/users_controller.ts') })
}}}
import type { HttpContext } from '@adonisjs/core/http';

import { DateTime } from 'luxon';
import vine from '@vinejs/vine';
import { UsersProps } from '@story-cms/kit';
import User from '#models/user';
import Activity from '#models/activity';
import ActivityService from '#services/activity_service';
import {
  createUserValidator,
  updateUserValidator,
  validationMessages,
} from '#validators/user';
import Page from '#models/page';
import Ui from '#models/ui';
import Draft from '#models/draft';
import Chapter from '#models/chapter';

export default class UsersController {
  private async logActivity(
    userId: number | undefined,
    locale: string,
    action: Activity['action'],
  ) {
    if (!userId) return;

    const activity = new ActivityService();
    await activity.logAction(userId, locale, 'user', action);
  }

  private async getLastActivity(userId: number): Promise<string> {
    const activity = await Activity.query()
      .where('userId', userId)
      .orderBy('createdAt', 'desc')
      .first();

    if (!activity) {
      return 'No activity';
    }

    const date = activity.createdAt;
    const now = DateTime.now();
    const diff = now.diff(date, 'days').days;

    if (diff < 1) {
      return 'Today';
    } else if (diff < 2) {
      return 'Yesterday';
    } else if (diff < 7) {
      return date.toFormat('cccc');
    } else if (date.year === now.year) {
      const day = date.day;
      const ordinal =
        day === 1 || day === 21 || day === 31
          ? 'st'
          : day === 2 || day === 22
            ? 'nd'
            : day === 3 || day === 23
              ? 'rd'
              : 'th';
      return {{ '`${day}${ordinal} ${date.toFormat(\'MMMM\')}`' }};
    } else {
      return date.toFormat('dd/MM/yy');
    }
  }

  // show a list of all users
  public async index(ctx: HttpContext) {
    const users = await User.all();
    const props: UsersProps = {
      users: await Promise.all(
        users.map(async (user: User) => ({
          ...user.meta,
          lastActivity: await this.getLastActivity(user.id),
        })),
      ),
    };

    return ctx.inertia.render('UsersIndex', { ...props });
  }

  // patch a user's information
  public async update({ request, response, params, session, auth }: HttpContext) {
    const id = Number(params.id);
    const user = await User.findOrFail(id);

    try {
      vine.messagesProvider = validationMessages;
      const payload = await request.validateUsing(updateUserValidator);
      user.name = payload.name;
      user.email = payload.email;
      user.role = payload.role;
      user.language = payload.language;
      user.save();
      await this.logActivity(auth.user?.id, session.get('locale'), 'update_user');
    } catch (e) {
      session.flash('errorsBag', { other: e.message });
    }

    return response.redirect('/user', false, 303);
  }

  // delete a user
  public async destroy({ response, params, session, auth }: HttpContext) {
    const id = Number(params.id);
    const user = await User.findOrFail(id);
    try {
      // Set updatedBy to null in all related records to prevent foreign key constraint errors
      await Page.query().where('updatedBy', id).update({ updatedBy: null });
      await Ui.query().where('updatedBy', id).update({ updatedBy: null });
      await Draft.query().where('updatedBy', id).update({ updatedBy: null });
      await Chapter.query().where('updatedBy', id).update({ updatedBy: null });
      // Delete all activities for the user to prevent foreign key constraint errors
      await Activity.query().where('userId', id).delete();

      // Now we can safely delete the user
      await user.delete();
      await this.logActivity(auth.user?.id, session.get('locale'), 'delete_user');
    } catch (e) {
      session.flash('errorsBag', { other: e.message });
    }

    return response.redirect('/user', false, 303);
  }

  // create a new user
  public async store({ request, response, session, auth }: HttpContext) {
    vine.messagesProvider = validationMessages;
    const payload = await request.validateUsing(createUserValidator);

    try {
      await User.create({ ...payload, password: 'pending' });
      await this.logActivity(auth.user?.id, session.get('locale'), 'create_user');
    } catch (e) {
      // logger.error(e.message)
      session.flash('errorsBag', { other: e.message });
    }

    return response.redirect('/user', false, 303);
  }
}
