{{{
  exports({ to: app.makePath('app/controllers/drafts_controller.ts') })
}}}
import type { HttpContext } from '@adonisjs/core/http';
import db from '@adonisjs/lucid/services/db';

import { Activity, Chapter, Draft, type DraftEditProps } from '@story-cms/kit';
import cms from '@story-cms/kit/cms';
import { trimmedErrors } from '@story-cms/kit/helpers';
import providers from '#config/providers';
import DraftService from '#services/draft_service';
import IndexService from '#services/index_service';
import { draftValidator } from '#validators/bundle';

export default class DraftsController {
  public async create(ctx: HttpContext) {
    const { story, version } = cms.storyContextFrom(ctx);
    if (story === undefined) return ctx.response.notFound();

    const indexService = new IndexService(story);
    const number = await indexService.getNewChapterNumber(version);
    if (number > story.chapterLimit) return ctx.response.redirect('/');

    const service = new DraftService(story);
    // TODO: set your own prefill fields
    service.setPrefilledFields(['imageUrl', 'type']);
    const bundle = await service.getDraftBundle(version, number);
    if (bundle === null) return ctx.response.redirect('/');

    await Draft.create({
      ...version,
      number,
      bundle,
    });

    await Activity.create({
      userId: ctx.auth.user?.id,
      locale: version.locale,
      action: `created draft for ${story.name} # ${number}`,
    });

    return ctx.response.redirect(
      `/${version.locale}/story/${story.id}/draft/${number}/edit`,
    );
  }

  public async edit(ctx: HttpContext) {
    const { story, version } = cms.storyContextFrom(ctx);
    if (story === undefined) return ctx.response.notFound();

    const specifier = {
      apiVersion: version.apiVersion,
      locale: version.locale,
      storyId: story.id,
      number: Number(ctx.params.number),
    };

    let draft = await Draft.query().where(specifier).first();
    let lastPublished = '';

    const chapter = await Chapter.query().where(specifier).first();

    if (chapter) {
      lastPublished = chapter.updatedAt ? chapter.updatedAt.toString() : '';
    }

    if (!draft) {
      if (!chapter) {
        return ctx.response.notFound();
      }
      lastPublished = chapter.updatedAt.toString();
      draft = await Draft.create({
        ...specifier,
        bundle: chapter.bundle,
      });
    }

    const indexService = new IndexService(story);
    await indexService.buildIndex(version);

    const data: DraftEditProps = {
      draft: draft.meta,
      bundle: draft!.bundle,
      lastPublished,
      providers,
      story,
      hasEditReview: cms.config.stories.hasEditReview,
    };

    const isTranslation = version.locale !== cms.config.languages.languages[0].locale;

    if (!isTranslation) {
      return ctx.inertia.render('DraftIndex', { ...data, ...cms.sharedProps(ctx) });
    }

    const source = await Chapter.query()
      .where({
        ...specifier,
        locale: cms.config.languages.languages[0].locale,
      })
      .first();

    return ctx.inertia.render('TranslationIndex', {
      ...data,
      source: source?.bundle,
      ...cms.sharedProps(ctx),
    });
  }

  // Only saving the draft without performing any validation
  public async save(ctx: HttpContext) {
    const { story, version } = cms.storyContextFrom(ctx);
    if (!story) return ctx.response.notFound();

    try {
      const id = Number(ctx.params.id);
      const draft = await Draft.findOrFail(id);

      draft.bundle = ctx.request.input('bundle');
      await draft.save();
      await Activity.create({
        userId: ctx.auth.user?.id,
        locale: version.locale,
        action: `updated draft for ${story.name} # ${draft.number}`,
      });
      const service = new IndexService(story);
      await service.buildIndex(draft.version);
    } catch (e) {
      const errors = e.messages || e.message || 'Error while saving this draft. Sorry!';
      ctx.session.flash('errorsBag', errors);
    }

    return ctx.response.redirect().back();
  }

  public async submit(ctx: HttpContext) {
    const { story, version } = cms.storyContextFrom(ctx);
    if (story === undefined) return ctx.response.notFound();

    const id = Number(ctx.params.id);
    const draft = await Draft.findOrFail(id);

    let payload;

    try {
      const data = ctx.request.all();
      payload = await draftValidator.validate(data);
    } catch (e) {
      const errors = trimmedErrors(e);
      ctx.session.flash('errorsBag', errors);
      return ctx.response.redirect().back();
    }

    const service = new IndexService(story);

    draft.bundle = JSON.stringify(payload.bundle);
    draft.status = 'submitted';
    draft.feedback = '';
    await draft.save();
    await Activity.create({
      userId: ctx.auth.user?.id,
      locale: version.locale,
      action: `submitted draft for ${story.name} # ${draft.number}`,
    });
    await service.buildIndex(draft.version);
    return ctx.response.redirect().back();
  }

  public async reject(ctx: HttpContext) {
    const { version, story } = cms.storyContextFrom(ctx);
    if (story === undefined) return ctx.response.notFound();

    const id = Number(ctx.params.id);
    const draft = await Draft.findOrFail(id);
    draft.status = 'started';
    draft.feedback = ctx.request.input('feedback');

    await draft.save();

    await Activity.create({
      userId: ctx.auth.user?.id,
      locale: version.locale,
      action: `rejected draft for ${story.name} # ${draft.number}`,
    });

    return ctx.response.redirect().back();
  }

  public async publish(ctx: HttpContext) {
    const { story } = cms.storyContextFrom(ctx);
    if (story === undefined) return ctx.response.notFound();

    const id = Number(ctx.params.id);
    const draft = await Draft.findOrFail(id);

    try {
      const data = ctx.request.all();
      const payload = await draftValidator.validate(data);
      draft.bundle = JSON.stringify(payload.bundle);
    } catch (e) {
      const errors = trimmedErrors(e);
      ctx.session.flash('errorsBag', errors);
      return ctx.response.redirect().back();
    }

    draft.bundle = ctx.request.input('bundle');
    const version = { ...draft.version };

    await db.transaction(async (trx) => {
      let chapter = await Chapter.query()
        .where({ ...draft.specifier })
        .first();

      if (chapter === null) {
        chapter = new Chapter().fill({ ...draft.specifier, bundle: draft.bundle });
      } else {
        chapter.bundle = draft.bundle;
      }

      chapter.useTransaction(trx);
      draft.useTransaction(trx);
      await chapter.save();
      await Activity.create({
        userId: ctx.auth.user?.id,
        locale: version.locale,
        action: `published chapter for ${story.name} # ${chapter.number}`,
      });
      await draft.delete();
    });

    // update the index after the transaction
    const service = new IndexService(story);
    await service.buildIndex(version);

    return ctx.response.redirect(`/${version.locale}/story/${story.id}`);
  }

  public async delete(ctx: HttpContext) {
    const { story } = cms.storyContextFrom(ctx);
    if (story === undefined) return ctx.response.notFound();

    const id = Number(ctx.params.id);
    const draft = await Draft.findOrFail(id);

    const version = { ...draft.version };
    await draft.delete();

    await Activity.create({
      userId: ctx.auth.user?.id,
      locale: version.locale,
      action: `deleted draft for ${story.name} # ${draft.number}`,
    });

    const service = new IndexService(story);
    await service.buildIndex(version);

    return ctx.response.redirect(`/${version.locale}/story/${story.id}`, false, 303);
  }
}
