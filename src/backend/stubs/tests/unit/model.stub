{{{ 
  exports({ to: app.makePath('tests/unit/model.spec.ts') }) 
}}}
import { test } from '@japa/runner';
import testUtils from '@adonisjs/core/services/test_utils';
import { DateTime } from 'luxon';

import {
  User,
  Campaign,
  Draft,
  Chapter,
  Index,
  UserFactory,
  CampaignFactory,
  ChapterFactory,
  IndexFactory,
  DraftFactory,
  PageFactory,
  CampaignFactory,
  Campaign,
} from '@story-cms/kit';
import cmsConfig from '#config/cms';

test.group('User', (group) => {
  group.each.setup(() => testUtils.db().withGlobalTransaction());

  test('users are persisted', async ({ assert }) => {
    const user = await UserFactory.create();
    assert.isTrue(user.$isPersisted);

    const users = await UserFactory.createMany(3);
    assert.lengthOf(users, 3);
  });

  test('user password is hashed during save', async ({ assert }) => {
    const user = new User();
    user.email = 'jake@example.com';
    user.name = 'Jake Polyglot';
    user.password = 'super secret';
    await user.save();

    assert.notEqual(user.password, 'super secret');
  });

  test('user has default language', async ({ assert }) => {
    const user = await UserFactory.merge({
      language: null,
    }).create();

    assert.isNull(user.language);
    assert.equal(user.defaultLanguage(), 'en');
    assert.equal(user.defaultLanguage('es'), 'es');

    user.language = 'th';
    assert.equal(user.defaultLanguage(), 'th');
    assert.equal(user.defaultLanguage('en'), 'th');

    user.language = '*';
    assert.equal(user.defaultLanguage(), 'en');
    assert.equal(user.defaultLanguage('th'), 'th');
  });

  test('user identified as manager', async ({ assert }) => {
    const user = await UserFactory.merge({
      language: null,
    }).create();

    assert.isNull(user.language);
    assert.equal(user.isManager, false);

    user.language = 'th';
    assert.equal(user.isManager, false);

    user.language = '*';
    assert.equal(user.isManager, true);
  });

  test('user identified as admin', async ({ assert }) => {
    const user = await UserFactory.merge({
      role: 'admin',
    }).create();

    assert.equal(user.isAdmin, true);

    user.role = 'editor';
    assert.equal(user.isAdmin, false);
  });

  test('user has initials', async ({ assert }) => {
    const user = await UserFactory.merge({
      name: '',
    }).create();

    assert.equal(user.initials, '');

    user.name = 'Robert';
    assert.equal(user.initials, 'R');

    user.name = "Robert M'Cheyne";
    assert.equal(user.initials, 'RM');

    user.name = "Robert Murray M'Cheyne";
    assert.equal(user.initials, 'RM');

    user.name = "  Robert   M'Cheyne     ";
    assert.equal(user.initials, 'RM');
  });
});

test.group('Chapter', (group) => {
  group.each.setup(() => testUtils.db().withGlobalTransaction());

  test('chapters are persisted', async ({ assert }) => {
    const user = await UserFactory.create();

    const chapter = await ChapterFactory.merge({
      updatedBy: user.id,
      bundle: '{"title": "Adam and Eve"}',
    }).create();
    assert.isTrue(chapter.$isPersisted);

    const fresh = await Chapter.findOrFail(chapter.id);

    assert.equal(fresh.parsedBundle['title'], 'Adam and Eve');
  });
});

test.group('Index', (group) => {
  group.each.setup(() => testUtils.db().withGlobalTransaction());

  test('index has list and publicList', async ({ assert }) => {
    const index = new Index().fill({
      storyId: 1,
      publishedList: [2, 3],
      items: {
        root: [
          {
            title: 'Adam and Eve',
            number: 1,
            imageUrl: 'pic1',
            reference: 'Genesis 1',
            part: 1,
          },
          { title: 'Noah', number: 2, imageUrl: 'pic2', reference: 'Genesis 6', part: 1 },
          {
            title: 'David',
            number: 3,
            imageUrl: 'pic2',
            reference: '1 Samuel 13',
            part: 1,
          },
        ],
      },
    });

    assert.equal(index.list.length, 3);
    assert.equal(index.publicList.length, 2);
    assert.equal(index.publicList[0].title, 'Noah');
    assert.equal(index.publicList[0].part, 1);
  });

  test('indecis are persisted', async ({ assert }) => {
    const index = await IndexFactory.merge({
      items: {
        root: [
          {
            title: 'Adam and Eve',
            number: 1,
            imageUrl: 'pic1',
            reference: 'Genesis 1',
            part: 1,
          },
          {
            title: 'David',
            number: 2,
            imageUrl: 'pic2',
            reference: '1 Samuel 13',
            part: 1,
          },
        ],
      },
    }).create();
    assert.isTrue(index.$isPersisted);

    const fresh = await Index.findOrFail(index.id);

    assert.equal(fresh.list[1].title, 'David');
    assert.equal(fresh.list[1].reference, '1 Samuel 13');
  });
});

test.group('Draft', (group) => {
  group.each.setup(() => testUtils.db().withGlobalTransaction());

  test('it can give an index item', async ({ assert }) => {
    const draft = await Draft.create({
      storyId: 1,
      locale: 'en',
      apiVersion: 1,
      number: 2,
      bundle:
        '{"title": "Adam and Eve", "part": 1, "sections": [], "imageUrl":"https://test.com", "passage": {"reference": "Genesis 1", "text": "In the beginning..."}}',
    });
    // read the draft to parse the bundle to an object
    await draft.refresh();
    assert.equal(draft.index.number, 2);
    assert.equal(draft.index.imageUrl, 'https://test.com');
    assert.equal(draft.index.title, 'Adam and Eve');
  });

  test('it can give a scope', async ({ assert }) => {
    const draft = await Draft.create({
      storyId: 1,
      locale: 'en',
      apiVersion: 1,
      number: 2,
      bundle: '{"title": "Adam and Eve", "sections": [], "imageUrl":"https://test.com"}',
    });

    const expected = {
      storyId: 1,
      locale: 'en',
      apiVersion: 1,
      number: 2,
    };

    const scope = draft.specifier;

    assert.equal(scope.storyId, expected.storyId);
    assert.equal(scope.locale, expected.locale);
    assert.equal(scope.apiVersion, expected.apiVersion);
    assert.equal(scope.number, expected.number);
  });

  test('drafts are persisted', async ({ assert }) => {
    const draft = await DraftFactory.merge({
      storyId: 1,
      bundle: '{"title": "Adam and Eve"}',
      status: 'submitted',
    }).create();
    assert.isTrue(draft.$isPersisted);

    const fresh = await Draft.findOrFail(draft.id);

    assert.equal(fresh.parsedBundle['title'], 'Adam and Eve');
    assert.equal(fresh.status, 'submitted');
  });
});

test.group('Page', (group) => {
  group.each.setup(() => testUtils.db().withGlobalTransaction());

  test('it identifies the type', async ({ assert }) => {
    const page = await PageFactory.merge({
      bundle: JSON.stringify({
        body: 'https://test.com',
      }),
    }).create();
    assert.isTrue(page.isLink);
  });

  test('it can add tracking to links', async ({ assert }) => {
    const tracking = cmsConfig.pages.tracking;

    const page = await PageFactory.merge({
      bundle: JSON.stringify({
        body: 'https://test.com',
      }),
    }).make();
    assert.equal(page.bundleWithTracking(tracking).body, {{{ '`https://test.com?${tracking}`' }}});

    const withQuery = await PageFactory.merge({
      bundle: JSON.stringify({
        body: 'https://test.com?q=1&q=some+other+thing',
      }),
    }).make();
    assert.equal(
      withQuery.bundleWithTracking(tracking).body,
      {{{ '`https://test.com?q=1&q=some+other+thing&${tracking}`' }}},
    );

    const withComplexQuery = await PageFactory.merge({
      bundle: JSON.stringify({
        body: 'https://test.com?q=is+it+worth+it?',
      }),
    }).make();
    assert.equal(
      withComplexQuery.bundleWithTracking(tracking).body,
      {{{ '`https://test.com?q=is+it+worth+it?&${tracking}`' }}},
    );
  });

  test('it can update the bundle', async ({ assert }) => {
    const page = await PageFactory.merge({
      bundle: JSON.stringify({
        junk: 'Should not be in the bundle',
        body: 'the original body',
        icon: 'https://test.com',
      }),
    }).create();

    page.updateBundle({ title: 'Adam and Eve', icon: '' });

    assert.isString(page.bundle);
    const updated = JSON.parse(page.bundle);

    // removes junk
    assert.isUndefined(updated.junk);
    // updates fresh attributes
    assert.equal(updated.title, 'Adam and Eve');
    // adds missing attributes
    assert.equal(page.parsedBundle.description, '');
    // adds missing attributes with default
    assert.equal(page.parsedBundle.group, 1);
    // does not change existing attributes
    assert.equal(page.parsedBundle.body, 'the original body');
    // deletes attributes that are empty
    assert.equal(page.parsedBundle.icon, '');
  });
});

test.group('Campaign', (group) => {
  group.each.setup(() => testUtils.db().withGlobalTransaction());

  test('campaigns are persisted', async ({ assert }) => {
    const campaign = await CampaignFactory.create();
    assert.isTrue(campaign.$isPersisted);

    const campaigns = await CampaignFactory.createMany(3);
    assert.lengthOf(campaigns, 3);
  });

  test('campaign bundle is accessible as object', async ({ assert }) => {
    const window = '2025-12-15T05:54:00.000Z|2025-12-18T05:53:00.000Z';
    const campaign = await CampaignFactory.merge({
      bundle: {
        name: 'Test Campaign',
        window: window,
        title: 'Campaign Title',
        message: 'Campaign message',
        actionLabel: 'Click Here',
        actionType: 'close',
      },
    }).create();

    assert.isTrue(campaign.$isPersisted);

    const fresh = await Campaign.findOrFail(campaign.id);
    // refresh to ensure bundle is parsed
    await fresh.refresh();

    assert.equal((fresh.model as any).name, 'Test Campaign');
    assert.equal((fresh.model as any).window, window);
    assert.equal((fresh.model as any).title, 'Campaign Title');
    assert.equal((fresh.model as any).message, 'Campaign message');
    assert.equal((fresh.model as any).actionLabel, 'Click Here');
    assert.equal((fresh.model as any).actionType, 'close');
  });

  test('it can update the bundle', async ({ assert }) => {
    const window = '2025-12-15T05:54:00.000Z|2025-12-18T05:53:00.000Z';
    const campaign = await CampaignFactory.merge({
      bundle: {
        junk: 'Should not be in the bundle',
        name: 'Original Name',
        window: window,
        title: 'Original Title',
        message: 'Original message',
        actionLabel: 'Original Label',
        actionType: 'close',
      },
    }).create();

    campaign.updateBundle({
      name: 'Updated Name',
      title: 'Updated Title',
      message: 'Updated message',
      actionLabel: 'Updated Label',
      actionType: 'externalUrl',
      actionUrl: 'https://example.com',
      isPublished: true,
    });

    // removes junk
    assert.isUndefined((campaign.model as any).junk);
    // updates fresh attributes
    assert.equal((campaign.model as any).name, 'Updated Name');
    assert.equal((campaign.model as any).title, 'Updated Title');
    assert.equal((campaign.model as any).message, 'Updated message');
    assert.equal((campaign.model as any).actionLabel, 'Updated Label');
    assert.equal((campaign.model as any).actionType, 'externalUrl');
    assert.equal((campaign.model as any).actionUrl, 'https://example.com');
    // isPublished is updated separately
    assert.equal(campaign.isPublished, true);
  });

  test('campaign has default stats', async ({ assert }) => {
    const campaign = await CampaignFactory.merge({
      stats: {},
    }).create();

    assert.deepEqual(campaign.stats, {});
    assert.isObject(campaign.stats);
  });

  test('campaign can have custom stats', async ({ assert }) => {
    const campaign = await CampaignFactory.merge({
      stats: {
        impressions: 100,
        clicks: 25,
      },
    }).create();

    assert.equal(campaign.stats.impressions, 100);
    assert.equal(campaign.stats.clicks, 25);
  });

  test('campaign has meta and model properties', async ({ assert }) => {
    const window = '2025-12-15T05:54:00.000Z|2025-12-18T05:53:00.000Z';
    const campaign = await CampaignFactory.merge({
      bundle: {
        name: 'Test Campaign',
        window: window,
        title: 'Test Title',
        message: 'Test message',
        actionLabel: 'Test Action',
        actionType: 'donate',
      },
      isPublished: true,
    }).create();

    assert.isObject(campaign.meta);
    assert.isObject(campaign.model);
    assert.equal((campaign.model as any).name, 'Test Campaign');
    assert.isTrue(campaign.isPublished);
  });

  test('splitWindow returns valid DateTime tuple for normal window', async ({
    assert,
  }) => {
    const startDate = '2025-12-15T05:54:00.000Z';
    const endDate = '2025-12-18T05:53:00.000Z';
    const window = {{ '`${startDate}|${endDate}`' }};
    const campaign = await CampaignFactory.merge({
      bundle: {
        name: 'Test Campaign',
        window: window,
      },
    }).create();

    const [start, end] = (campaign as any).splitWindow;

    assert.isNotNull(start);
    assert.isNotNull(end);
    assert.isTrue(start instanceof DateTime);
    assert.isTrue(end instanceof DateTime);
    assert.isTrue(start.isValid);
    assert.isTrue(end.isValid);
    assert.equal(start.toISO(), startDate);
    assert.equal(end.toISO(), endDate);
  });

  test('splitWindow returns null tuple for undefined window', async ({ assert }) => {
    const campaign = await CampaignFactory.merge({
      bundle: {
        name: 'Test Campaign',
      },
    }).create();

    const [start, end] = (campaign as any).splitWindow;

    assert.isNull(start);
    assert.isNull(end);
  });

  test('splitWindow returns null tuple for null window', async ({ assert }) => {
    const campaign = await CampaignFactory.merge({
      bundle: {
        name: 'Test Campaign',
        window: null,
      },
    }).create();

    const [start, end] = (campaign as any).splitWindow;

    assert.isNull(start);
    assert.isNull(end);
  });

  test('splitWindow returns null tuple for empty window string', async ({ assert }) => {
    const campaign = await CampaignFactory.merge({
      bundle: {
        name: 'Test Campaign',
        window: '',
      },
    }).create();

    const [start, end] = (campaign as any).splitWindow;

    assert.isNull(start);
    assert.isNull(end);
  });

  test('splitWindow handles missing pipe separator', async ({ assert }) => {
    const campaign = await CampaignFactory.merge({
      bundle: {
        name: 'Test Campaign',
        window: '2025-12-15T05:54:00.000Z',
      },
    }).create();

    const [start, end] = (campaign as any).splitWindow;

    assert.isNotNull(start);
    assert.isNull(end);
    assert.isTrue(start instanceof DateTime);
    assert.isTrue(start.isValid);
    assert.equal(start.toISO(), '2025-12-15T05:54:00.000Z');
  });

  test('splitWindow handles multiple pipes', async ({ assert }) => {
    const campaign = await CampaignFactory.merge({
      bundle: {
        name: 'Test Campaign',
        window:
          '2025-12-15T05:54:00.000Z|2025-12-18T05:53:00.000Z|2025-12-20T05:53:00.000Z',
      },
    }).create();

    const [start, end] = (campaign as any).splitWindow;

    assert.isNotNull(start);
    assert.isNotNull(end);
    assert.isTrue(start instanceof DateTime);
    assert.isTrue(end instanceof DateTime);
    assert.isTrue(start.isValid);
    assert.isTrue(end.isValid);
    assert.equal(start.toISO(), '2025-12-15T05:54:00.000Z');
    // Should only take the first two parts, end will be the second part
    assert.equal(end.toISO(), '2025-12-18T05:53:00.000Z');
  });

  test('splitWindow handles invalid ISO date strings', async ({ assert }) => {
    const campaign = await CampaignFactory.merge({
      bundle: {
        name: 'Test Campaign',
        window: 'invalid-date|also-invalid',
      },
    }).create();

    const [start, end] = (campaign as any).splitWindow;

    assert.isNull(start);
    assert.isNull(end);
  });

  test('splitWindow handles only start date (no end date)', async ({ assert }) => {
    const campaign = await CampaignFactory.merge({
      bundle: {
        name: 'Test Campaign',
        window: '2025-12-15T05:54:00.000Z|',
      },
    }).create();

    const [start, end] = (campaign as any).splitWindow;

    assert.isNotNull(start);
    assert.isNull(end);
    assert.isTrue(start instanceof DateTime);
    assert.isTrue(start.isValid);
    assert.equal(start.toISO(), '2025-12-15T05:54:00.000Z');
  });

  test('splitWindow handles only end date (no start date)', async ({ assert }) => {
    const campaign = await CampaignFactory.merge({
      bundle: {
        name: 'Test Campaign',
        window: '|2025-12-18T05:53:00.000Z',
      },
    }).create();

    const [start, end] = (campaign as any).splitWindow;

    assert.isNull(start);
    assert.isNotNull(end);
    assert.isTrue(end instanceof DateTime);
    assert.isTrue(end.isValid);
    assert.equal(end.toISO(), '2025-12-18T05:53:00.000Z');
  });

  test('splitWindow handles empty dates on both sides', async ({ assert }) => {
    const campaign = await CampaignFactory.merge({
      bundle: {
        name: 'Test Campaign',
        window: '|',
      },
    }).create();

    const [start, end] = (campaign as any).splitWindow;

    assert.isNull(start);
    assert.isNull(end);
  });

  test('splitWindow handles whitespace around dates', async ({ assert }) => {
    const startDate = '2025-12-15T05:54:00.000Z';
    const endDate = '2025-12-18T05:53:00.000Z';
    const campaign = await CampaignFactory.merge({
      bundle: {
        name: 'Test Campaign',
        window: {{ '`  ${startDate}  |  ${endDate}  `' }},
      },
    }).create();

    const [start, end] = (campaign as any).splitWindow;

    assert.isNotNull(start);
    assert.isNotNull(end);
    assert.isTrue(start instanceof DateTime);
    assert.isTrue(end instanceof DateTime);
    // DateTime.fromISO should handle whitespace, but let's verify behavior
    // If it doesn't trim, the dates will be invalid
    if (start.isValid) {
      assert.equal(start.toISO(), startDate);
    }
    if (end.isValid) {
      assert.equal(end.toISO(), endDate);
    }
  });

  test('splitWindow handles partial ISO dates', async ({ assert }) => {
    const campaign = await CampaignFactory.merge({
      bundle: {
        name: 'Test Campaign',
        window: '2025-12-15|2025-12-18',
      },
    }).create();

    const [start, end] = (campaign as any).splitWindow;

    assert.isNotNull(start);
    assert.isNotNull(end);
    assert.isTrue(start instanceof DateTime);
    assert.equal(start.day, 15);
    assert.isTrue(end instanceof DateTime);
    assert.equal(end.day, 18);
    // Partial dates might be valid or invalid depending on DateTime.fromISO behavior
    // We just verify they are DateTime instances
    assert.isTrue(start instanceof DateTime);
    assert.isTrue(end instanceof DateTime);
  });
});
